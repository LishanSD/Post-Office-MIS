// import AuthService from "../../services/authservice";
// import { EmployeeRepository } from "../../repositeries/employeerepository";
// import BcryptService from "../../services/cryptservice";
// import JwtService from "../../services/jwtservice";
// import SessionStore from "../../services/sessionstore";

// jest.mock("../../repositeries/employeerepository");
// jest.mock("../../services/cryptservice");
// jest.mock("../../services/jwtservice");
// jest.mock("../../services/sessionstore");

// describe("AuthService", () => {
//   let authService: AuthService;
//   let employeeRepository: jest.Mocked<EmployeeRepository>;
//   let cryptService: jest.Mocked<BcryptService>;
//   let jwtService: jest.Mocked<JwtService>;
//   let sessionStore: jest.Mocked<SessionStore>;

//   beforeEach(() => {
//     employeeRepository = new EmployeeRepository() as jest.Mocked<EmployeeRepository>;
//     cryptService = new BcryptService() as jest.Mocked<BcryptService>;
//     jwtService = new JwtService() as jest.Mocked<JwtService>;
//     sessionStore = new SessionStore() as jest.Mocked<SessionStore>;
//     authService = new AuthService(employeeRepository, cryptService, sessionStore, jwtService);
//   });

//   describe("login", () => {
//     it("should return login success response when credentials are correct", async () => {
//       const mockEmployee = { password: "hashedPassword", role: "admin" };
//       const mockUserData = {
//         employeeName: "John Doe",
//         postalCode: "12345",
//         role: "admin",
//         postOfficeName: "Main Office",
//         email: "john.doe@example.com",
//       };

//       employeeRepository.findUserbyID.mockResolvedValue(mockEmployee);
//       cryptService.comparePassword.mockResolvedValue(true);
//       jwtService.sign.mockReturnValue("mockToken");
//       employeeRepository.getUserData.mockResolvedValue(mockUserData);

//       const response = await authService.login("username", "password");

//       expect(response).toEqual({
//         name: "John Doe",
//         postalCode: "12345",
//         role: "admin",
//         message: "login success",
//         login: true,
//         postOfficeName: "Main Office",
//         token: "mockToken",
//         email: "john.doe@example.com",
//         employeeID: "username",
//       });
//     });

//     it("should return login denied response when credentials are incorrect", async () => {
//       const mockEmployee = { password: "hashedPassword" };

//       employeeRepository.findUserbyID.mockResolvedValue(mockEmployee);
//       cryptService.comparePassword.mockResolvedValue(false);

//       const response = await authService.login("username", "password");

//       expect(response).toEqual({
//         message: "login denied",
//         login: false,
//       });
//     });

//     it("should return incorrect employeeID response when employee is not found", async () => {
//       employeeRepository.findUserbyID.mockResolvedValue(null);

//       const response = await authService.login("username", "password");

//       expect(response).toEqual({
//         message: "Incorrect employeeID",
//         login: false,
//       });
//     });

//     it("should return login failed response when an error occurs", async () => {
//       employeeRepository.findUserbyID.mockRejectedValue(new Error("error"));

//       const response = await authService.login("username", "password");

//       expect(response).toEqual({
//         message: "login failed",
//         login: false,
//       });
//     });
//   });

//   describe("authorize", () => {
//     it("should call next when token is valid", async () => {
//       const req = {
//         headers: {
//           authorization: "Bearer mockToken",
//         },
//       } as unknown as Request;
//       const res = {} as Response;
//       const next = jest.fn();

//       jwtService.verify.mockReturnValue({ sessionId: "mockSessionId" });

//       await authService.authorize(req, res, next);

//       expect(next).toHaveBeenCalled();
//     });

//     it("should return 401 when token is not provided", async () => {
//       const req = {
//         headers: {},
//       } as unknown as Request;
//       const res = {
//         status: jest.fn().mockReturnThis(),
//         json: jest.fn(),
//       } as unknown as Response;
//       const next = jest.fn();

//       await authService.authorize(req, res, next);

//       expect(res.status).toHaveBeenCalledWith(401);
//       expect(res.json).toHaveBeenCalledWith({ message: "No token provided" });
//     });

//     it("should return 401 when token is invalid", async () => {
//       const req = {
//         headers: {
//           authorization: "Bearer invalidToken",
//         },
//       } as unknown as Request;
//       const res = {
//         status: jest.fn().mockReturnThis(),
//         json: jest.fn(),
//       } as unknown as Response;
//       const next = jest.fn();

//       jwtService.verify.mockImplementation(() => {
//         throw new Error("Invalid token");
//       });

//       await authService.authorize(req, res, next);

//       expect(res.status).toHaveBeenCalledWith(401);
//       expect(res.json).toHaveBeenCalledWith({ message: "Failed to authenticate token" });
//     });
//   });

//   describe("setPassword", () => {
//     it("should change password when newPassword and passwordCopy match", async () => {
//       cryptService.hashPassword.mockResolvedValue("hashedNewPassword");
//       employeeRepository.changePassword.mockResolvedValue(true);

//       const response = await authService.setPassword("employeeID", "newPassword", "newPassword");

//       expect(response).toBe(true);
//       expect(cryptService.hashPassword).toHaveBeenCalledWith("newPassword");
//       expect(employeeRepository.changePassword).toHaveBeenCalledWith("employeeID", "hashedNewPassword");
//     });

//     it("should not change password when newPassword and passwordCopy do not match", async () => {
//       const response = await authService.setPassword("employeeID", "newPassword", "differentPassword");

//       expect(response).toBeUndefined();
//       expect(cryptService.hashPassword).not.toHaveBeenCalled();
//       expect(employeeRepository.changePassword).not.toHaveBeenCalled();
//     });
//   });
// });